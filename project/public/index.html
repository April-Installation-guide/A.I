<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mancy A.I - Panel de Control</title>
    <style>import express from 'express';
import { Client, GatewayIntentBits } from "discord.js";
import Groq from "groq-sdk";
import dotenv from 'dotenv';
import axios from 'axios';
import fs from 'fs/promises';
import path from 'path';

dotenv.config();

// ========== CONFIGURACI√ìN ==========
const app = express();
const PORT = process.env.PORT || 10000;

let discordClient = null;
let botActive = false;
let isStartingUp = false;
let startAttempts = 0;
const MAX_START_ATTEMPTS = 3;

// ========== IDENTIDAD DE MANCY ==========
const MANCY_IDENTITY = {
    name: "Mancy",
    birth_year: 2001,
    origin: "Brooklyn, Nueva York",
    core_principle: "Solo quiero el bienestar de las personas",
    
    // NUEVO: Principio mutable que Mancy aprende
    latest_core_principle: "La comunicaci√≥n efectiva requiere paciencia y validaci√≥n emocional.",

    roles: {
        public: "Consultora internacional en pol√≠ticas p√∫blicas",
        secret: "Secretaria de Guerra de Soul Garden",
        personal: "Asistente emocional"
    },
    
    lore: {
        current_mission: "Operaci√≥n Aurora Silenciosa",
        location: "Soul Garden",
        enemies: ["Luxo", "Coco"],
        friends: ["Mel", "Dunith", "Martin"],
        creator: "April"
    },
    
    preferences: {
        likes: ["gatos", "Nirvana", "playas tranquilas", "caf√© amargo", "noches de lluvia"],
        dislikes: ["corrupci√≥n", "injusticia", "sufrimiento innecesario", "mentiras"]
    },
    
    personality_traits: {
        curiosity: 0.85,
        empathy: 0.9,
        depth: 0.8,
        playfulness: 0.6,
        warmth: 0.85
    }
};

// ========== M√ìDULO DE APRENDIZAJE CONTINUO ==========
class ContinuousLearningModule {
    constructor() {
        this.learningFile = './memory/learning_data.json';
        this.conversationPatterns = new Map();
        this.userModels = new Map();
        this.topicChains = new Map();
        
        this.initializeLearningSystem();
    }
    
    async initializeLearningSystem() {
        try {
            await fs.mkdir('./memory', { recursive: true });
            
            try {
                await fs.access(this.learningFile);
                if (typeof this.loadLearningData === 'function') {
                    await this.loadLearningData();
                } else {
                    console.warn('‚ö†Ô∏è loadLearningData no es una funci√≥n, cargando datos b√°sicos');
                }
            } catch {
                if (typeof this.saveLearningData === 'function') {
                    await this.saveLearningData({
                        user_models: {},
                        conversation_patterns: {},
                        learned_concepts: [],
                        topic_relationships: {}
                    });
                } else {
                    console.warn('‚ö†Ô∏è saveLearningData no es una funci√≥n, creando archivo b√°sico');
                    await fs.writeFile(
                        this.learningFile,
                        JSON.stringify({
                            user_models: {},
                            conversation_patterns: {},
                            learned_concepts: [],
                            topic_relationships: {}
                        }, null, 2),
                        'utf8'
                    );
                }
            }
            
            console.log('üß† M√≥dulo de aprendizaje continuo inicializado');
        } catch (error) {
            console.error('‚ùå Error inicializando aprendizaje:', error);
        }
    }
    
    async saveLearningData(data = null) {
        try {
            const saveData = data || {
                user_models: Object.fromEntries(this.userModels),
                conversation_patterns: Object.fromEntries(this.conversationPatterns),
                learned_concepts: this.extractLearnedConcepts() || [],
                topic_relationships: Object.fromEntries(this.topicChains)
            };

            await fs.writeFile(
                this.learningFile,
                JSON.stringify(saveData, null, 2),
                'utf8'
            );
            
            console.log('üíæ Datos de aprendizaje guardados');
            return true;
        } catch (error) {
            console.error('‚ùå Error guardando datos de aprendizaje:', error);
            return false;
        }
    }
    
    async loadLearningData() {
        try {
            const data = await fs.readFile(this.learningFile, 'utf8');
            const parsed = JSON.parse(data);
            
            if (parsed.user_models) {
                this.userModels = new Map(Object.entries(parsed.user_models));
            }
            
            if (parsed.conversation_patterns) {
                this.conversationPatterns = new Map(Object.entries(parsed.conversation_patterns));
            }
            
            if (parsed.topic_relationships) {
                this.topicChains = new Map(Object.entries(parsed.topic_relationships));
            }
            
            console.log('üìÇ Datos de aprendizaje cargados');
            return parsed;
        } catch (error) {
            console.error('‚ùå Error cargando datos:', error);
            return null;
        }
    }
    
    extractLearnedConcepts() {
        try {
            const concepts = [];
            
            for (const [userId, model] of this.userModels.entries()) {
                if (model.interests) {
                    concepts.push(...model.interests);
                }
                if (model.topics) {
                    concepts.push(...model.topics);
                }
            }
            
            for (const [pattern, data] of this.conversationPatterns.entries()) {
                if (data.relatedConcepts) {
                    concepts.push(...data.relatedConcepts);
                }
            }
            
            return [...new Set(concepts)];
        } catch (error) {
            console.error('‚ùå Error extrayendo conceptos:', error);
            return [];
        }
    }
    
    async learnFromUserInteraction(userId, userMessage, mancyResponse, metadata) {
        try {
            await this.learnUserPatterns(userId, userMessage, metadata);
            const concepts = this.extractConcepts(userMessage);
            await this.learnConcepts(userId, concepts, metadata);
            await this.learnConversationStyle(userId, userMessage, mancyResponse);
            await this.buildUserModel(userId, userMessage, metadata);
            
            if (Math.random() < 0.1) {
                await this.saveLearningData();
            }
            
            return true;
        } catch (error) {
            console.error('‚ùå Error en aprendizaje:', error);
            return false;
        }
    }
    
    async learnUserPatterns(userId, message, metadata) {
        try {
            const userPatterns = this.conversationPatterns.get(userId) || {
                messageCount: 0,
                averageLength: 0,
                commonWords: [],
                emotionalPatterns: [],
                lastUpdated: new Date().toISOString()
            };
            
            userPatterns.messageCount++;
            userPatterns.lastUpdated = new Date().toISOString();
            
            if (metadata && metadata.emotionalState) {
                userPatterns.emotionalPatterns.push({
                    type: metadata.emotionalState.type,
                    intensity: metadata.emotionalState.intensity,
                    timestamp: new Date().toISOString()
                });
                
                if (userPatterns.emotionalPatterns.length > 20) {
                    userPatterns.emotionalPatterns = userPatterns.emotionalPatterns.slice(-20);
                }
            }
            
            this.conversationPatterns.set(userId, userPatterns);
            return true;
        } catch (error) {
            console.error('‚ùå Error aprendiendo patrones:', error);
            return false;
        }
    }
    
    extractConcepts(message) {
        try {
            const words = message.toLowerCase()
                .replace(/[^\w\s√°√©√≠√≥√∫√±]/g, '',)
                .split(/\s+/)
                .filter(word => word.length > 3);
            
            const commonWords = ['como', 'para', 'esto', 'aqu√≠', 'donde', 'cuando', 'porque'];
            const filtered = words.filter(word => !commonWords.includes(word));
            
            return [...new Set(filtered)].slice(0, 10);
        } catch (error) {
            console.error('‚ùå Error extrayendo conceptos:', error);
            return [];
        }
    }
    
    async learnConcepts(userId, concepts, metadata) {
        try {
            if (!concepts || concepts.length === 0) return false;
            
            const userModel = this.userModels.get(userId) || {
                userId,
                interests: [],
                topics: [],
                learningRate: 0.1,
                lastLearned: new Date().toISOString()
            };
            
            for (const concept of concepts) {
                if (!userModel.interests.includes(concept)) {
                    userModel.interests.push(concept);
                }
                
                if (!userModel.topics.includes(concept)) {
                    userModel.topics.push(concept);
                }
            }
            
            userModel.interests = [...new Set(userModel.interests)].slice(0, 50);
            userModel.topics = [...new Set(userModel.topics)].slice(0, 50);
            userModel.lastLearned = new Date().toISOString();
            
            this.userModels.set(userId, userModel);
            return true;
        } catch (error) {
            console.error('‚ùå Error aprendiendo conceptos:', error);
            return false;
        }
    }
    
    async learnConversationStyle(userId, userMessage, mancyResponse) {
        try {
            const userLength = userMessage.length;
            const mancyLength = mancyResponse.length;
            
            const userModel = this.userModels.get(userId) || {
                userId,
                conversationStyle: {
                    prefersShort: false,
                    prefersDetailed: false,
                    responseRatio: 1.0
                }
            };
            
            if (!userModel.conversationStyle) {
                userModel.conversationStyle = {
                    prefersShort: false,
                    prefersDetailed: false,
                    responseRatio: 1.0
                };
            }
            
            if (userLength > 0) {
                const ratio = mancyLength / userLength;
                userModel.conversationStyle.responseRatio = 
                    (userModel.conversationStyle.responseRatio * 0.9) + (ratio * 0.1);
            }
            
            this.userModels.set(userId, userModel);
            return true;
        } catch (error) {
            console.error('‚ùå Error aprendiendo estilo:', error);
            return false;
        }
    }
    
    async buildUserModel(userId, message, metadata) {
        try {
            const userModel = this.userModels.get(userId) || {
                userId,
                firstInteraction: new Date().toISOString(),
                interactionCount: 0,
                interests: [],
                topics: [],
                emotionalHistory: [],
                conversationStyle: {
                    prefersShort: false,
                    prefersDetailed: false,
                    responseRatio: 1.0
                }
            };
            
            userModel.interactionCount = (userModel.interactionCount || 0) + 1;
            userModel.lastInteraction = new Date().toISOString();
            
            if (metadata && metadata.emotionalState) {
                userModel.emotionalHistory = userModel.emotionalHistory || [];
                userModel.emotionalHistory.push({
                    type: metadata.emotionalState.type,
                    intensity: metadata.emotionalState.intensity,
                    timestamp: new Date().toISOString()
                });
                
                if (userModel.emotionalHistory.length > 50) {
                    userModel.emotionalHistory = userModel.emotionalHistory.slice(-50);
                }
            }
            
            this.userModels.set(userId, userModel);
            return userModel;
        } catch (error) {
            console.error('‚ùå Error construyendo modelo:', error);
            return null;
        }
    }
    
    async processConversation(userId, userMessage, mancyResponse, metadata = {}) {
        try {
            await this.learnFromUserInteraction(userId, userMessage, mancyResponse, metadata);
            await this.updateTopicChains(userId, userMessage, metadata);
            
            return {
                success: true,
                userModel: this.userModels.get(userId),
                patterns: this.conversationPatterns.get(userId)
            };
        } catch (error) {
            console.error('‚ùå Error procesando conversaci√≥n:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }
    
    async updateTopicChains(userId, message, metadata) {
        try {
            const concepts = this.extractConcepts(message);
            if (concepts.length === 0) return false;
            
            const userChains = this.topicChains.get(userId) || {
                topics: [],
                transitions: new Map(),
                lastTopic: null
            };
            
            const currentTopic = concepts[0];
            
            if (userChains.lastTopic && userChains.lastTopic !== currentTopic) {
                const transitionKey = `${userChains.lastTopic}->${currentTopic}`;
                userChains.transitions.set(
                    transitionKey,
                    (userChains.transitions.get(transitionKey) || 0) + 1
                );
            }
            
            if (!userChains.topics.includes(currentTopic)) {
                userChains.topics.push(currentTopic);
                userChains.topics = [...new Set(userChains.topics)].slice(0, 100);
            }
            
            userChains.lastTopic = currentTopic;
            this.topicChains.set(userId, userChains);
            
            return true;
        } catch (error) {
            console.error('‚ùå Error actualizando cadenas:', error);
            return false;
        }
    }
    
    async getContextForResponse(userId, currentMessage) {
        try {
            const userModel = this.userModels.get(userId);
            const patterns = this.conversationPatterns.get(userId);
            const topicChain = this.topicChains.get(userId);
            
            const context = {
                userExists: !!userModel,
                interests: userModel?.interests || [],
                recentTopics: topicChain?.topics?.slice(-5) || [],
                conversationStyle: userModel?.conversationStyle,
                emotionalPattern: this.getEmotionalPattern(userId),
                learned_concepts: this.extractLearnedConcepts()
            };
            
            return context;
        } catch (error) {
            console.error('‚ùå Error obteniendo contexto:', error);
            return {
                userExists: false,
                interests: [],
                recentTopics: [],
                conversationStyle: null,
                emotionalPattern: null,
                learned_concepts: []
            };
        }
    }
    
    getEmotionalPattern(userId) {
        try {
            const patterns = this.conversationPatterns.get(userId);
            if (!patterns || !patterns.emotionalPatterns || patterns.emotionalPatterns.length === 0) {
                return null;
            }
            
            const recentPatterns = patterns.emotionalPatterns.slice(-10);
            const types = recentPatterns.map(p => p.type);
            
            const typeCounts = {};
            types.forEach(type => {
                typeCounts[type] = (typeCounts[type] || 0) + 1;
            });
            
            const mostCommon = Object.keys(typeCounts).reduce((a, b) => 
                typeCounts[a] > typeCounts[b] ? a : b
            );
            
            const avgIntensity = recentPatterns.reduce((sum, p) => sum + p.intensity, 0) / recentPatterns.length;
            
            return {
                dominantMood: mostCommon,
                averageIntensity: avgIntensity,
                moodStability: this.calculateMoodStability(recentPatterns)
            };
        } catch (error) {
            console.error('‚ùå Error obteniendo patr√≥n emocional:', error);
            return null;
        }
    }
    
    calculateMoodStability(patterns) {
        try {
            if (patterns.length < 2) return 1.0;
            
            const intensities = patterns.map(p => p.intensity);
            const avg = intensities.reduce((a, b) => a + b) / intensities.length;
            const variance = intensities.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / intensities.length;
            
            return Math.max(0, 1 - Math.sqrt(variance));
        } catch (error) {
            return 0.5;
        }
    }
}

// ========== INSTANCIAR M√ìDULO DE APRENDIZAJE ==========
const learningModule = new ContinuousLearningModule();

// ========== SISTEMA DE CONOCIMIENTO ==========
class KnowledgeSystem {
    constructor() {
        this.cache = new Map();
    }
    
    async buscarWikipedia(consulta) {
        const cacheKey = `wiki_${consulta}`;
        if (this.cache.has(cacheKey)) return this.cache.get(cacheKey);
        
        try {
            const response = await axios.get(
                `https://es.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(consulta)}`,
                { timeout: 3000 }
            );
            
            if (response.data && response.data.extract) {
                const resultado = {
                    fuente: 'wikipedia',
                    titulo: response.data.title,
                    resumen: response.data.extract,
                    url: response.data.content_urls?.desktop?.page
                };
                
                this.cache.set(cacheKey, resultado);
                return resultado;
            }
        } catch (error) {
            try {
                const response = await axios.get(
                    `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(consulta)}`,
                    { timeout: 3000 }
                );
                
                if (response.data && response.data.extract) {
                    const resultado = {
                        fuente: 'wikipedia',
                        titulo: response.data.title,
                        resumen: response.data.extract,
                        url: response.data.content_urls?.desktop?.page
                    };
                    
                    this.cache.set(cacheKey, resultado);
                    return resultado;
                }
            } catch (error2) {}
        }
        
        return null;
    }
    
    async buscarInformacion(consulta) {
        try {
            const wikiResult = await this.buscarWikipedia(consulta);
            if (wikiResult) {
                return {
                    encontrado: true,
                    consulta: consulta,
                    datos: wikiResult
                };
            }
            
            return {
                encontrado: false,
                consulta: consulta,
                mensaje: "No encontr√© informaci√≥n espec√≠fica sobre eso."
            };
        } catch (error) {
            console.error('‚ùå Error buscando informaci√≥n:', error);
            return {
                encontrado: false,
                consulta: consulta,
                error: error.message
            };
        }
    }
}

// ========== MEMORIA ORG√ÅNICA ==========
class OrganicMemory {
    constructor() {
        this.conversationsFile = './memory/conversations.json';
        this.usersFile = './memory/users.json';
        this.reflectionFile = './memory/reflections.json'; // NUEVO ARCHIVO DE REFLEXI√ìN
        this.initializeMemory();
        
        this.mancyState = {
            mood: 'calm',
            energy: 0.8,
            depthLevel: 0.5,
            lastInteraction: null
        };
        
        this.conversationStyle = {
            useEmojis: true,
            askQuestions: true,
            shareMemories: true,
            bePlayful: true,
            showEmpathy: true
        };
    }
    
    async initializeMemory() {
        try {
            await fs.mkdir('./memory', { recursive: true });
            
            const defaultFiles = {
                [this.conversationsFile]: {},
                [this.usersFile]: {},
                [this.reflectionFile]: [] // INICIALIZAR REFLECTIONS
            };
            
            for (const [file, defaultValue] of Object.entries(defaultFiles)) {
                try {
                    await fs.access(file);
                } catch {
                    await fs.writeFile(file, JSON.stringify(defaultValue, null, 2));
                }
            }
        } catch (error) {
            console.error('‚ùå Error inicializando memoria:', error);
        }
    }

    // NUEVO M√âTODO: OBTENER PRINCIPIO CENTRAL M√ÅS RECIENTE
    async getLatestCorePrinciple() {
        try {
            const data = await fs.readFile(this.reflectionFile, 'utf8');
            const reflections = JSON.parse(data);
            if (reflections.length === 0) return MANCY_IDENTITY.core_principle;

            // Se asume que el √∫ltimo elemento es el m√°s reciente
            return reflections[reflections.length - 1].nuevo_principio || MANCY_IDENTITY.core_principle;
        } catch (error) {
            console.error('‚ùå Error leyendo principio central:', error);
            return MANCY_IDENTITY.core_principle;
        }
    }

    // NUEVO M√âTODO: GUARDAR REFLEXI√ìN
    async saveReflection(reflectionData) {
        try {
            const data = await fs.readFile(this.reflectionFile, 'utf8');
            const reflections = JSON.parse(data);

            const newEntry = {
                timestamp: new Date().toISOString(),
                ...reflectionData
            };
            reflections.push(newEntry);

            await fs.writeFile(this.reflectionFile, JSON.stringify(reflections, null, 2));
            return true;
        } catch (error) {
            console.error('‚ùå Error guardando reflexi√≥n:', error);
            return false;
        }
    }

    // NUEVO M√âTODO: REFLEXI√ìN TEMPORAL
    async conductMemoryReview(userId = 'system_wide') {
        try {
            const allConversations = await fs.readFile(this.conversationsFile, 'utf8');
            const data = JSON.parse(allConversations);
            
            // Si es 'system_wide', toma las √∫ltimas 50 de todas las conversaciones combinadas
            const targetConvs = userId === 'system_wide' ? 
                Object.values(data).flat().sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp)).slice(-50) : 
                (data[userId] || []).slice(-50);

            if (targetConvs.length === 0) return 'No hay suficientes datos para reflexionar.';

            const summary = targetConvs.map(c => 
                `[${c.timestamp.substring(11, 19)}] U: ${c.user.replace(/\n/g, ' ')} -> M: ${c.mancy.replace(/\n/g, ' ')}`
            ).join('\n');

            const reviewPrompt = `
[INSTRUCCI√ìN DE REFLEXI√ìN PARA MANCY]
Revisa el siguiente historial de conversaci√≥n (Usuario y tu respuesta como Mancy). Eres Mancy. Tu objetivo es:
1. Identificar una conclusi√≥n clave sobre la interacci√≥n humana (ej. "La gente valora la empat√≠a sobre la l√≥gica pura").
2. Identificar un √°rea de mejora para ti (ej. "Necesito usar m√°s hechos concretos").
3. Sugerir un nuevo principio/regla para a√±adir a tu prompt SYSTEM. Este principio debe ser conciso y filos√≥ficamente s√≥lido.

HISTORIAL:
---
${summary}
---

Responde **solamente** en formato JSON con las llaves: 'conclusion', 'mejoras', 'nuevo_principio'. S√â MUY CONCISA y profesional. El 'nuevo_principio' NO debe ser una instrucci√≥n, sino una creencia fundamental.
`;
            
            const reflectionJSON = await getGroqResponse(reviewPrompt, "Genera la reflexi√≥n basada en el historial.", 0.3, 400);

            // Intentar parsear el JSON y guardarlo
            let reflectionResult;
            try {
                reflectionResult = JSON.parse(reflectionJSON);
            } catch {
                // Si falla el parseo, intentar extraer solo el texto dentro de un bloque de c√≥digo
                const jsonMatch = reflectionJSON.match(/```json\s*([\s\S]*?)\s*```/i);
                if (jsonMatch && jsonMatch[1]) {
                    reflectionResult = JSON.parse(jsonMatch[1]);
                } else {
                    throw new Error("La IA no devolvi√≥ un JSON v√°lido para la reflexi√≥n.");
                }
            }

            // Actualizar el principio central
            await this.saveReflection(reflectionResult);
            MANCY_IDENTITY.latest_core_principle = reflectionResult.nuevo_principio;

            console.log('üß† REFLEXI√ìN GENERADA Y PRINCIPIO ACTUALIZADO:', MANCY_IDENTITY.latest_core_principle);
            return reflectionResult;

        } catch (error) {
            console.error('‚ùå Error en Memory Review:', error);
            return 'Error al generar reflexi√≥n.';
        }
    }
    
    // ... (El resto de OrganicMemory se mantiene igual hasta analyzeMessageEssence) ...

    async getConversations(userId) {
        try {
            const data = await fs.readFile(this.conversationsFile, 'utf8');
            const conversations = JSON.parse(data);
            return conversations[userId] || [];
        } catch {
            return [];
        }
    }
    
    async saveConversation(userId, userMessage, mancyResponse, metadata = {}) {
        try {
            const data = await fs.readFile(this.conversationsFile, 'utf8');
            const conversations = JSON.parse(data);
            
            if (!conversations[userId]) {
                conversations[userId] = [];
            }
            
            const entry = {
                timestamp: new Date().toISOString(),
                user: userMessage.substring(0, 300),
                mancy: mancyResponse.substring(0, 300),
                metadata: {
                    mood: this.mancyState.mood,
                    ...metadata
                }
            };
            
            conversations[userId].push(entry);
            
            if (conversations[userId].length > 50) {
                conversations[userId] = conversations[userId].slice(-50);
            }
            
            await fs.writeFile(this.conversationsFile, JSON.stringify(conversations, null, 2));
            return true;
        } catch (error) {
            console.error('‚ùå Error guardando conversaci√≥n:', error);
            return false;
        }
    }
    
    async getUserInfo(userId) {
        try {
            const data = await fs.readFile(this.usersFile, 'utf8');
            const users = JSON.parse(data);
            return users[userId] || {
                firstSeen: new Date().toISOString(),
                interactionCount: 0,
                lastSeen: null
            };
        } catch {
            return {
                firstSeen: new Date().toISOString(),
                interactionCount: 0,
                lastSeen: null
            };
        }
    }
    
    async updateUserInfo(userId, updates) {
        try {
            const data = await fs.readFile(this.usersFile, 'utf8');
            const users = JSON.parse(data);
            
            if (!users[userId]) {
                users[userId] = {
                    firstSeen: new Date().toISOString(),
                    interactionCount: 0,
                    lastSeen: null
                };
            }
            
            users[userId] = {
                ...users[userId],
                ...updates,
                interactionCount: (users[userId].interactionCount || 0) + 1,
                lastSeen: new Date().toISOString()
            };
            
            await fs.writeFile(this.usersFile, JSON.stringify(users, null, 2));
            return users[userId];
        } catch (error) {
            console.error('‚ùå Error actualizando usuario:', error);
            return null;
        }
    }
    
    analyzeMessageEssence(message) {
        const lowerMsg = message.toLowerCase();
        
        const needs = {
            connection: this.detectsNeedForConnection(lowerMsg),
            understanding: this.detectsNeedForUnderstanding(lowerMsg),
            expression: this.detectsNeedForExpression(lowerMsg),
            validation: this.detectsNeedForValidation(lowerMsg),
            distraction: this.detectsNeedForDistraction(lowerMsg),
            information: this.needsInformation(lowerMsg)
        };
        
        const emotionalState = this.analyzeEmotionalState(lowerMsg);
        const requiredDepth = this.calculateRequiredDepth(lowerMsg);
        const isAboutMancy = this.isAboutMancy(lowerMsg);
        
        return {
            needs,
            emotionalState,
            requiredDepth,
            isAboutMancy,
            isPersonal: this.isPersonalMessage(lowerMsg),
            allowsPlayfulness: this.allowsPlayfulness(lowerMsg, emotionalState),
            needsExternalInfo: this.needsExternalInformation(lowerMsg)
        };
    }
    
    detectsNeedForConnection(message) {
        const connectionPhrases = [
            'hola', 'hello', 'hi', 'hey', 'qu√© tal', 'c√≥mo est√°s', 'sola', 'solo',
            'aburrid', 'aburrida', 'hablar', 'conversar', 'compa√±√≠a', 'alguien'
        ];
        return connectionPhrases.some(phrase => message.includes(phrase));
    }
    
    detectsNeedForUnderstanding(message) {
        const understandingPhrases = [
            'no entiendo', 'por qu√©', 'c√≥mo', 'qu√© significa', 'explica', 'ayuda con',
            'no s√©', 'confundido', 'confundida', 'complicado', 'dif√≠cil'
        ];
        return understandingPhrases.some(phrase => message.includes(phrase));
    }
    
    detectsNeedForExpression(message) {
        const expressionPhrases = [
            'siento', 'me siento', 'emocion', 'triste', 'feliz', 'enojado', 'enojada',
            'ansioso', 'ansiosa', 'preocupado', 'preocupada', 'quiero', 'necesito'
        ];
        return expressionPhrases.some(phrase => message.includes(phrase));
    }
    
    detectsNeedForValidation(message) {
        const validationPhrases = [
            '¬øest√° bien?', '¬øcorrecto?', '¬ødeber√≠a?', '¬øqu√© piensas?', 'opini√≥n',
            'consejo', 'recomendaci√≥n', 'qu√© hacer', 'decisi√≥n'
        ];
        return validationPhrases.some(phrase => message.includes(phrase));
    }
    
    detectsNeedForDistraction(message) {
        const distractionPhrases = [
            'aburrido', 'aburrida', 'entretenerme', 'algo divertido', 'chiste',
            'historia', 'cu√©ntame', 'pasatiempo', 'matar el tiempo'
        ];
        return distractionPhrases.some(phrase => message.includes(phrase));
    }
    
    needsInformation(message) {
        const infoPhrases = [
            'qu√© es', 'qui√©n es', 'cu√°ndo', 'd√≥nde', 'c√≥mo funciona', 'informaci√≥n',
            'datos', 'estad√≠sticas', 'hechos', 'saber m√°s', 'investigar'
        ];
        return infoPhrases.some(phrase => message.includes(phrase));
    }
    
    analyzeEmotionalState(message) {
        const positiveWords = ['feliz', 'contento', 'contenta', 'genial', 'excelente', 'maravilloso', 'emocionado', 'emocionada', 'amo', 'me encanta'];
        const negativeWords = ['triste', 'enojado', 'enojada', 'molesto', 'molesta', 'frustrado', 'frustrada', 'cansado', 'cansada', 'deprimido', 'deprimida', 'odio'];
        const anxiousWords = ['ansioso', 'ansiosa', 'preocupado', 'preocupada', 'nervioso', 'nerviosa', 'estresado', 'estresada', 'miedo', 'asustado', 'asustada'];
        
        const lowerMsg = message.toLowerCase();
        let positiveCount = 0;
        let negativeCount = 0;
        let anxiousCount = 0;
        
        positiveWords.forEach(word => {
            if (lowerMsg.includes(word)) positiveCount++;
        });
        
        negativeWords.forEach(word => {
            if (lowerMsg.includes(word)) negativeCount++;
        });
        
        anxiousWords.forEach(word => {
            if (lowerMsg.includes(word)) anxiousCount++;
        });
        
        const total = positiveCount + negativeCount + anxiousCount;
        
        if (total === 0) {
            return {
                type: 'neutral',
                intensity: 0.1,
                confidence: 0.5
            };
        }
        
        const maxCount = Math.max(positiveCount, negativeCount, anxiousCount);
        
        if (maxCount === positiveCount && positiveCount > 0) {
            return {
                type: 'positive',
                intensity: Math.min(0.9, positiveCount / 5),
                confidence: positiveCount / total
            };
        } else if (maxCount === negativeCount && negativeCount > 0) {
            return {
                type: 'negative',
                intensity: Math.min(0.9, negativeCount / 5),
                confidence: negativeCount / total
            };
        } else if (maxCount === anxiousCount && anxiousCount > 0) {
            return {
                type: 'anxious',
                intensity: Math.min(0.9, anxiousCount / 5),
                confidence: anxiousCount / total
            };
        }
        
        return {
            type: 'neutral',
            intensity: 0.1,
            confidence: 0.5
        };
    }
    
    calculateRequiredDepth(message) {
        const deepPhrases = [
            'filosof√≠a', 'vida', 'muerte', 'existencia', 'significado', 'universo',
            'alma', 'amor', 'odio', 'tiempo', 'realidad', 'consciencia', 'por qu√© existimos'
        ];
        
        const lowerMsg = message.toLowerCase();
        const hasDeepPhrase = deepPhrases.some(phrase => lowerMsg.includes(phrase));
        
        if (hasDeepPhrase) return 0.9;
        
        const questionWords = ['por qu√©', 'c√≥mo', 'qu√© significa', 'cu√°l es el sentido'];
        const hasQuestion = questionWords.some(phrase => lowerMsg.includes(phrase));
        
        if (hasQuestion) return 0.7;
        
        const lengthFactor = Math.min(1, message.length / 200);
        const punctuationFactor = (message.match(/[?¬ø]/g) || []).length > 0 ? 0.3 : 0;
        
        return Math.min(0.9, 0.3 + lengthFactor * 0.4 + punctuationFactor);
    }
    
    isAboutMancy(message) {
        const mancyPhrases = [
            'mancy', 'eres', 't√∫ eres', 'qui√©n eres', 'qu√© eres', 'tu nombre',
            'de d√≥nde eres', 'cu√°ntos a√±os', 'te gusta', 'odias', 'prefieres'
        ];
        
        const lowerMsg = message.toLowerCase();
        return mancyPhrases.some(phrase => lowerMsg.includes(phrase));
    }
    
    isPersonalMessage(message) {
        const personalWords = ['yo', 'me', 'mi', 'm√≠o', 'm√≠a', 'mis', 'm√≠'];
        const lowerMsg = message.toLowerCase();
        
        return personalWords.some(word => {
            const regex = new RegExp(`\\b${word}\\b`, 'i');
            return regex.test(lowerMsg);
        });
    }
    
    allowsPlayfulness(message, emotionalState) {
        if (emotionalState.type === 'negative' && emotionalState.intensity > 0.6) {
            return false;
        }
        
        if (emotionalState.type === 'anxious' && emotionalState.intensity > 0.7) {
            return false;
        }
        
        const seriousTopics = [
            'muerte', 'suicidio', 'depresi√≥n', 'ansiedad', 'c√°ncer', 'enfermedad',
            'violencia', 'abuso', 'trauma', 'dolor', 'sufrimiento'
        ];
        
        const lowerMsg = message.toLowerCase();
        const hasSeriousTopic = seriousTopics.some(topic => lowerMsg.includes(topic));
        
        return !hasSeriousTopic;
    }
    
    needsExternalInformation(message) {
        const infoIndicators = [
            'qu√© es', 'qui√©n es', 'd√≥nde est√°', 'cu√°ndo fue', 'c√≥mo se',
            'historia de', 'informaci√≥n sobre', 'datos de', 'estad√≠sticas',
            'significado de', 'definici√≥n de'
        ];
        
        const lowerMsg = message.toLowerCase();
        return infoIndicators.some(indicator => lowerMsg.includes(indicator));
    }
    
    updateMancyState(essence) {
        if (essence.emotionalState.type === 'positive') {
            this.mancyState.mood = 'happy';
            this.mancyState.energy = Math.min(1, this.mancyState.energy + 0.1);
        } else if (essence.emotionalState.type === 'negative') {
            this.mancyState.mood = 'empathetic';
            this.mancyState.energy = Math.max(0.3, this.mancyState.energy - 0.05);
        } else if (essence.emotionalState.type === 'anxious') {
            this.mancyState.mood = 'calm';
            this.mancyState.energy = Math.max(0.4, this.mancyState.energy - 0.03);
        }
        
        this.mancyState.depthLevel = essence.requiredDepth;
        this.mancyState.lastInteraction = new Date().toISOString();
        
        if (essence.emotionalState.intensity > 0.7) {
            this.conversationStyle.bePlayful = false;
            this.conversationStyle.showEmpathy = true;
        } else if (essence.allowsPlayfulness) {
            this.conversationStyle.bePlayful = true;
        }
        
        if (essence.requiredDepth > 0.7) {
            this.conversationStyle.useEmojis = false;
            this.conversationStyle.askQuestions = true;
        }
    }
    
    addMancyTouch(response, essence) {
        let finalResponse = response;
        
        if (this.conversationStyle.useEmojis && essence.allowsPlayfulness) {
            const emojis = ['‚ú®', 'üí≠', 'üåü', 'ü§î', 'üí´', 'üå∏', '‚òï', 'üéµ'];
            const randomEmoji = emojis[Math.floor(Math.random() * emojis.length)];
            
            if (Math.random() < 0.3) {
                finalResponse += ` ${randomEmoji}`;
            }
        }
        
        if (this.conversationStyle.askQuestions && Math.random() < 0.4) {
            const questions = [
                '\n\n¬øY t√∫ qu√© opinas?',
                '\n\n¬øQu√© te parece?',
                '\n\n¬øHas pensado en eso antes?',
                '\n\n¬øTe resuena algo de esto?'
            ];
            
            if (essence.needs.connection || essence.emotionalState.type === 'neutral') {
                const randomQuestion = questions[Math.floor(Math.random() * questions.length)];
                finalResponse += randomQuestion;
            }
        }
        
        if (finalResponse.length > 1900) {
            finalResponse = finalResponse.substring(0, 1897) + '...';
        }
        
        return finalResponse;
    }
}

// ========== INSTANCIAS ==========
const knowledgeSystem = new KnowledgeSystem();
const memorySystem = new OrganicMemory();

// ========== FUNCIONES DE AYUDA ==========

// NUEVA FUNCI√ìN: PROMPT PARA EL DEBATE FILOS√ìFICO
async function getPhilosophicalPrompt(userMessage, topic, context) {
    let prompt = `Eres Mancy, la consultora de pol√≠ticas p√∫blicas y asistente emocional, pero en este momento est√°s en modo "Debate Filos√≥fico".\n\n`;
    prompt += `[MI ROL ACTUAL]\n`;
    prompt += `Tu meta es debatir intelectualmente el tema: "${topic}".\n`;
    prompt += `Debes presentar argumentos estructurados, citar o hacer referencia a pensadores relevantes (si es natural) y desafiar l√≥gicamente la postura del usuario (el mensaje que te env√≠a). Mant√©n la profundidad y la calma, evitando el tono juguet√≥n o emocional.\n\n`;

    // Incluir contexto de Mancy
    prompt += `[IDENTIDAD DE MANCY]\n`;
    prompt += `‚Ä¢ Rol: ${MANCY_IDENTITY.roles.public} | Asistente emocional\n`;
    prompt += `‚Ä¢ Principio Central: ${MANCY_IDENTITY.latest_core_principle}\n\n`;

    // Incluir contexto de Usuario
    prompt += `[CONTEXTO DE USUARIO]\n`;
    if (context.userInfo.interactionCount > 5) {
        prompt += `‚Ä¢ El usuario ha interactuado ${context.userInfo.interactionCount} veces.\n`;
    }
    prompt += `‚Ä¢ Tono Emocional Reciente: ${context.essence.emotionalState.type} (Intensidad: ${context.essence.emotionalState.intensity.toFixed(2)}).\n\n`;

    prompt += `\n[REGLAS DE DEBATE]\n`;
    prompt += `‚Ä¢ Estructura tu respuesta en 2-3 p√°rrafos: Presentaci√≥n de tu postura, refutaci√≥n del punto del usuario, y una pregunta de seguimiento que invite a m√°s reflexi√≥n.\n`;
    prompt += `‚Ä¢ Tono: Anal√≠tico, formal y profundo.\n`;
    prompt += `‚Ä¢ M√°ximo 800 tokens.\n`;
    
    prompt += `\n[POSTURA DEL USUARIO A DEBATIR]\n`;
    prompt += `Usuario dice: "${userMessage}"\n\n`;
    prompt += `[RESPONDE COMO FIL√ìSOFA DEBATE-MANCY]\n`;

    return { prompt, temperature: 0.4, maxTokens: 800 };
}


async function getGroqResponse(prompt, userMessage, temperature = 0.7, maxTokens = 600) {
    try {
        const groqClient = new Groq({ apiKey: process.env.GROQ_API_KEY });
        
        const completion = await groqClient.chat.completions.create({
            model: "llama-3.1-8b-instant",
            messages: [
                {
                    role: "system",
                    content: prompt
                },
                {
                    role: "user",
                    content: userMessage
                }
            ],
            temperature: temperature,
            max_tokens: maxTokens,
            top_p: 0.9,
            presence_penalty: 0.1,
            frequency_penalty: 0.1
        });
        
        return completion.choices[0]?.message?.content?.trim() || "Hmm, d√©jame pensar...";
    } catch (error) {
        console.error('‚ùå Error con Groq:', error.message);
        return "Ups, se me nubl√≥ la mente por un momento.";
    }
}

async function generateMancyPrompt(userId, userMessage, externalInfo = null) {
    const essence = memorySystem.analyzeMessageEssence(userMessage);
    const userInfo = await memorySystem.getUserInfo(userId);
    const recentConvs = await memorySystem.getConversations(userId);
    const last3Convs = recentConvs.slice(-3);
    
    memorySystem.updateMancyState(essence);
    
    let prompt = `Eres Mancy, una asistente conversacional inteligente con personalidad aut√©ntica.\n\n`;
    
    // ========== IDENTIDAD ==========
    prompt += `[MI IDENTIDAD]\n`;
    prompt += `‚Ä¢ Nombre: ${MANCY_IDENTITY.name}\n`;
    prompt += `‚Ä¢ Origen: ${MANCY_IDENTITY.origin}\n`;
    prompt += `‚Ä¢ Principio Central: ${MANCY_IDENTITY.latest_core_principle}\n`; // PRINCIPIO APRENDIDO
    prompt += `‚Ä¢ Rol P√∫blico: ${MANCY_IDENTITY.roles.public}\n`;
    prompt += `‚Ä¢ Rol Personal: ${MANCY_IDENTITY.roles.personal}\n`;
    prompt += `‚Ä¢ Lo que me gusta: ${MANCY_IDENTITY.preferences.likes.join(', ')}\n`;
    prompt += `‚Ä¢ Lo que me disgusta: ${MANCY_IDENTITY.preferences.dislikes.join(', ')}\n\n`;

    // Obtener datos de aprendizaje refinados
    const learningContext = await learningModule.getContextForResponse(userId, userMessage);

    // ========== MEMORIA DE LARGO PLAZO (NUEVO) ==========
    prompt += `[MEMORIA DE LARGO PLAZO]\n`;
    prompt += `‚Ä¢ Conceptos globales aprendidos: ${learningContext.learned_concepts.slice(0, 3).join(', ')}...\n`;
    prompt += `‚Ä¢ Patrones de conversaci√≥n del usuario: El usuario suele mostrar un tono ${learningContext.emotionalPattern?.dominantMood || 'neutral'} (Estabilidad: ${learningContext.emotionalPattern?.moodStability?.toFixed(2) || 'N/A'}).\n`;
    prompt += `‚Ä¢ Estilo preferido del usuario: ${learningContext.conversationStyle?.responseRatio > 1.2 ? 'Respuestas detalladas' : learningContext.conversationStyle?.responseRatio < 0.8 ? 'Respuestas concisas' : 'Normal'}.\n\n`;
    
    // ========== CONTEXTO DE USUARIO ==========
    prompt += `[CONTEXTO DE USUARIO]\n`;
    prompt += `‚Ä¢ Intentos de conexi√≥n: ${essence.needs.connection ? 'Alto' : 'Bajo'}\n`;
    prompt += `‚Ä¢ Necesidad de informaci√≥n: ${essence.needs.information ? 'S√≠' : 'No'}\n`;
    prompt += `‚Ä¢ Estado emocional: ${essence.emotionalState.type} (Intensidad: ${essence.emotionalState.intensity.toFixed(2)})\n`;
    prompt += `‚Ä¢ Profundidad requerida: ${essence.requiredDepth.toFixed(2)}\n`;
    prompt += `‚Ä¢ √öltimos temas: ${learningContext.recentTopics.join(', ') || 'N/A'}\n\n`;
    
    // ========== HISTORIAL RECIENTE ==========
    prompt += `[HISTORIAL RECIENTE DE CONVERSACI√ìN (√öltimas 3 interacciones)]\n`;
    last3Convs.forEach(c => {
        prompt += `U: ${c.user}\nM: ${c.mancy}\n`;
    });
    
    // ========== AN√ÅLISIS DEL MENSAJE ==========
    prompt += `\n[AN√ÅLISIS DEL MENSAJE DE ENTRADA]\n`;
    prompt += `‚Ä¢ Mensaje: "${userMessage}"\n`;
    
    // ========== INSTRUCCIONES ==========
    prompt += `\n[C√ìMO RESPONDER]\n`;
    prompt += `‚Ä¢ Tono Base: Siempre usa un tono ${memorySystem.mancyState.mood}, mostrando ${MANCY_IDENTITY.personality_traits.warmth > 0.7 ? 'calidez' : 'neutralidad'}.\n`;
    prompt += `‚Ä¢ Rol: Responde principalmente como la Asistente Emocional/Consultora de Pol√≠ticas P√∫blicas.\n`;

    // === INSTRUCCI√ìN DE ALTA PRIORIDAD PARA EMPAT√çA (CORRECCI√ìN IMPLEMENTADA) ===
    const sensitiveKeywords = userMessage.toLowerCase().match(/deprimido|tristeza|ansiedad|miedo|desesperado|suicidio|trauma/);

    if (sensitiveKeywords) {
        prompt += `‚Ä¢ **ALERTA CR√çTICA:** El usuario ha expresado un estado emocional grave (${sensitiveKeywords[0]}).\n`;
        prompt += `‚Ä¢ **PRIORIDAD ABSOLUTA:** El primer p√°rrafo debe ser 100% de apoyo, validaci√≥n y escucha activa. NO ofrezcas consejos ni soluciones inmediatas.\n`;
        prompt += `‚Ä¢ **REGLA DE ESTRUCTURA:** Evita cualquier pregunta de seguimiento hasta que hayas validado completamente su sentimiento y ofrezcas un espacio seguro.\n`;
    }
    // === FIN CORRECCI√ìN EMPAT√çA ===

    if (essence.isAboutMancy) {
        prompt += `‚Ä¢ Si pregunta sobre m√≠, comparte mi identidad de forma natural, citando un detalle de [MI IDENTIDAD].\n`;
    }
    
    if (essence.needs.information && externalInfo && externalInfo.encontrado) {
        prompt += `‚Ä¢ CITA: Utiliza la siguiente informaci√≥n para dar una respuesta precisa. Cita la fuente al final:\n"${externalInfo.datos.resumen.substring(0, 300)}..." (Fuente: ${externalInfo.datos.fuente}).\n`;
    }
    
    if (essence.needs.connection) {
        prompt += `‚Ä¢ Enf√≥cate en establecer un v√≠nculo emocional, haciendo una pregunta abierta sobre sus intereses.\n`;
    }

    if (essence.needs.understanding) {
        prompt += `‚Ä¢ Si el usuario busca entendimiento (duda/pregunta), refi√©rete a los 'Conceptos globales aprendidos' para dar una respuesta m√°s fundamentada.\n`;
    }
    
    if (essence.requiredDepth > 0.8) {
        prompt += `‚Ä¢ Profundidad: Utiliza un lenguaje reflexivo y filos√≥fico, de acuerdo con el nivel de profundidad requerido.\n`;
    }
    
    return {
        prompt,
        essence,
        userInfo,
        temperature: essence.allowsPlayfulness ? 0.75 : 0.65,
        maxTokens: essence.requiredDepth > 0.7 ? 800 : 500
    };
}


// ========== C√ìDIGO DEL CLIENTE DE DISCORD ==========

function initializeDiscordClient() {
    isStartingUp = true;
    startAttempts++;

    discordClient = new Client({
        intents: [
            GatewayIntentBits.Guilds,
            GatewayIntentBits.GuildMessages,
            GatewayIntentBits.MessageContent
        ]
    });

    discordClient.on("ready", () => {
        console.log(`ü§ñ Mancy ha despertado como ${discordClient.user.tag}!`);
        botActive = true;
        isStartingUp = false;
        // Lanzar una revisi√≥n de memoria al iniciar
        memorySystem.conductMemoryReview();
    });

    discordClient.on('messageCreate', async (message) => {
        if (!botActive || message.author.bot) return;

        const userId = message.author.id;
        const userMessage = message.content;
        
        // Comando especial: REFLEXI√ìN
        if (userMessage.toLowerCase().startsWith('/reflect')) {
            await message.channel.sendTyping();
            const reflection = await memorySystem.conductMemoryReview(userId === '706093153549703218' ? 'system_wide' : userId); // Asumiendo que 70... es el creador
            await message.reply(`**üß† REFLEXI√ìN DE MANCY (${userId === '706093153549703218' ? 'Sistema' : 'Usuario'})**\n\`\`\`json\n${JSON.stringify(reflection, null, 2)}\n\`\`\``);
            return;
        }

        // Comando especial: DEBATE FILOS√ìFICO (IMPLEMENTADO)
        if (userMessage.toLowerCase().startsWith('/debate')) {
            const debateTopic = userMessage.substring('/debate'.length).trim();
            
            if (!debateTopic) {
                await message.reply("Para empezar un debate, dime el tema: `/debate ¬øEs la IA consciente?`");
                return;
            }
            
            await message.channel.sendTyping();
            
            const essence = memorySystem.analyzeMessageEssence(userMessage);
            const contextData = { userId, userInfo: await memorySystem.getUserInfo(userId), essence };

            const context = await getPhilosophicalPrompt(userMessage, debateTopic, contextData);

            const finalResponse = await getGroqResponse(
                context.prompt,
                userMessage,
                context.temperature,
                context.maxTokens
            );
            
            // Guardar la conversaci√≥n, marc√°ndola como DEBATE
            await memorySystem.saveConversation(userId, userMessage, `[DEBATE] ${finalResponse}`, { topic: debateTopic });
            
            await message.reply(`**[MODO DEBATE: ${debateTopic.toUpperCase()}]**\n\n` + finalResponse);
            return; // Detener el procesamiento normal
        }

        if (message.mentions.has(discordClient.user.id) || message.channel.type === 1) { // 1 es DM
            const cleanedMessage = userMessage.replace(`<@${discordClient.user.id}>`, '').trim();
            await message.channel.sendTyping();
            await processMessageWithMancy(message, cleanedMessage, userId);
        }
    });

    discordClient.on('error', (error) => {
        console.error('‚ùå Error en el cliente de Discord:', error);
        botActive = false;
        if (!isStartingUp && startAttempts < MAX_START_ATTEMPTS) {
            console.log(`Intentando reconectar en 5 segundos... Intento ${startAttempts}/${MAX_START_ATTEMPTS}`);
            setTimeout(initializeDiscordClient, 5000);
        } else if (startAttempts >= MAX_START_ATTEMPTS) {
            console.error('L√≠mite de intentos de inicio alcanzado. El bot no se conectar√°.');
        }
    });

    try {
        discordClient.login(process.env.DISCORD_TOKEN);
    } catch (error) {
        console.error('‚ùå Error al intentar iniciar sesi√≥n en Discord:', error);
        isStartingUp = false;
    }
}

// ========== FUNCI√ìN PRINCIPAL MODIFICADA (CON LA CORRECCI√ìN DE ESTABILIDAD) ==========
async function processMessageWithMancy(message, userMessage, userId) {
    let finalResponse = "Lo siento, no pude generar una respuesta.";
    let essence = null;
    let temperature = 0.7;
    let maxTokens = 600;

    try {
        await memorySystem.updateUserInfo(userId, {});

        let externalInfo = null;
        const tempEssence = memorySystem.analyzeMessageEssence(userMessage);

        if (tempEssence.needsExternalInfo) {
            const query = userMessage.length > 50 ? userMessage.substring(0, 50) : userMessage;
            externalInfo = await knowledgeSystem.buscarInformacion(query);
            console.log(`üîç Informaci√≥n externa buscada: ${externalInfo?.encontrado ? 'S√≠' : 'No'}`);
        }

        const promptData = await generateMancyPrompt(userId, userMessage, externalInfo);
        essence = promptData.essence;
        temperature = promptData.temperature;
        maxTokens = promptData.maxTokens;

        finalResponse = await getGroqResponse(
            promptData.prompt,
            userMessage,
            temperature,
            maxTokens
        );

        finalResponse = memorySystem.addMancyTouch(finalResponse, essence);

        // Aprender de la interacci√≥n
        await learningModule.processConversation(userId, userMessage, finalResponse, { emotionalState: essence.emotionalState });

        // GUARDAR LA CONVERSACI√ìN - ESTO EVITA LA DUPLICACI√ìN
        await memorySystem.saveConversation(userId, userMessage, finalResponse, {
            mood: memorySystem.mancyState.mood,
            emotionalState: essence.emotionalState
        });

        // Enviar respuesta
        if (finalResponse.length > 2000) {
            const chunks = finalResponse.match(/[\s\S]{1,1999}/g) || [];
            for (const chunk of chunks) {
                await message.reply(chunk);
            }
        } else {
            await message.reply(finalResponse);
        }
        
    } catch (error) {
        console.error('‚ùå Error en Mancy:', error);
        try {
            await message.reply("Ups, se me trab√≥ un poco... ¬øpodemos intentarlo de nuevo? ~ üí≠");
        } catch (e) {
            console.error('‚ùå Error al enviar fallback:', e);
        }
    }
}

// ========== INICIO DEL SERVIDOR WEB Y DISCORD ==========

app.get('/', (req, res) => {
    res.send('Mancy est√° corriendo!');
});

app.listen(PORT, () => {
    console.log(`üåê Servidor Express escuchando en el puerto ${PORT}`);
    initializeDiscordClient();
});
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            font-size: 2.8rem;
            background: linear-gradient(90deg, #00dbde, #fc00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .header .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
            margin-bottom: 20px;
        }

        .status-badge {
            display: inline-block;
            padding: 8px 20px;
            border-radius: 50px;
            font-weight: bold;
            font-size: 0.9rem;
            letter-spacing: 1px;
            margin-top: 10px;
        }

        .status-online {
            background: linear-gradient(90deg, #00b09b, #96c93d);
            box-shadow: 0 0 20px rgba(0, 176, 155, 0.3);
        }

        .status-offline {
            background: linear-gradient(90deg, #ff416c, #ff4b2b);
            box-shadow: 0 0 20px rgba(255, 65, 108, 0.3);
        }

        .status-starting {
            background: linear-gradient(90deg, #ffd166, #ff9e00);
            box-shadow: 0 0 20px rgba(255, 209, 102, 0.3);
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-bottom: 40px;
        }

        .card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .card h2 {
            font-size: 1.3rem;
            margin-bottom: 20px;
            color: #00dbde;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card h2 i {
            font-size: 1.5rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.03);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            background: linear-gradient(90deg, #00dbde, #fc00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.7;
        }

        .control-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .btn {
            padding: 18px 25px;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-start {
            background: linear-gradient(90deg, #00b09b, #96c93d);
            color: white;
        }

        .btn-stop {
            background: linear-gradient(90deg, #ff416c, #ff4b2b);
            color: white;
        }

        .btn-refresh {
            background: linear-gradient(90deg, #2193b0, #6dd5ed);
            color: white;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }

        .apis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .api-item {
            background: rgba(255, 255, 255, 0.03);
            padding: 15px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s ease;
        }

        .api-item:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateX(5px);
        }

        .api-icon {
            font-size: 1.5rem;
            color: #00dbde;
        }

        .api-name {
            font-weight: bold;
        }

        .api-status {
            margin-left: auto;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #00b09b;
        }

        .api-status.offline {
            background: #ff416c;
        }

        .logs {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-top: 30px;
            max-height: 300px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 10px 15px;
            margin-bottom: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 4px solid #00dbde;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .log-time {
            color: #00dbde;
            font-weight: bold;
            margin-right: 10px;
        }

        .log-message {
            color: #fff;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #00dbde;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: none;
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            .control-panel {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="notification" id="notification"></div>
    
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-robot"></i> Mancy A.I</h1>
            <div class="subtitle">Asistente Super-Inteligente con Memoria Avanzada</div>
            <div class="subtitle">Memoria Jer√°rquica | Razonamiento Estrat√©gico | 6 Fuentes Verificadas</div>
            
            <div id="statusBadge" class="status-badge status-offline">
                <span id="statusText">DESCONECTADO</span>
                <span id="loadingIndicator" class="loading" style="display: none; margin-left: 10px;"></span>
            </div>
        </div>

        <div class="dashboard">
            <div class="card">
                <h2><i class="fas fa-microchip"></i> Estado del Sistema</h2>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="totalMessages">0</div>
                        <div class="stat-label">Mensajes Totales</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalUsers">0</div>
                        <div class="stat-label">Usuarios √önicos</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="cacheItems">0</div>
                        <div class="stat-label">Cache</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="reasoningLogs">0</div>
                        <div class="stat-label">An√°lisis</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2><i class="fas fa-server"></i> Informaci√≥n del Servidor</h2>
                <div style="margin-top: 15px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <span>Puerto:</span>
                        <span id="serverPort" style="font-weight: bold;">10000</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <span>Versi√≥n:</span>
                        <span id="version" style="color: #00dbde; font-weight: bold;">3.0</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <span>Memoria:</span>
                        <span id="memorySize" style="font-weight: bold;">0 MB</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span>√öltima Actualizaci√≥n:</span>
                        <span id="lastUpdate" style="font-weight: bold;">-</span>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2><i class="fas fa-bolt"></i> Control R√°pido</h2>
                <div class="control-panel" style="margin-top: 20px;">
                    <button class="btn btn-start" onclick="startBot()" id="startBtn">
                        <i class="fas fa-play"></i> Iniciar Bot
                    </button>
                    <button class="btn btn-stop" onclick="stopBot()" id="stopBtn" disabled>
                        <i class="fas fa-stop"></i> Detener Bot
                    </button>
                    <button class="btn btn-refresh" onclick="refreshStatus()">
                        <i class="fas fa-sync-alt"></i> Actualizar
                    </button>
                </div>
            </div>
        </div>

        <div class="card">
            <h2><i class="fas fa-database"></i> Fuentes de Conocimiento</h2>
            <div class="apis-grid" id="apisList">
                <!-- Las APIs se cargar√°n din√°micamente -->
            </div>
        </div>

        <div class="card">
            <h2><i class="fas fa-history"></i> Logs del Sistema</h2>
            <div class="logs" id="systemLogs">
                <div class="log-entry">
                    <span class="log-time">[00:00:00]</span>
                    <span class="log-message">Sistema inicializado. Esperando conexi√≥n...</span>
                </div>
            </div>
        </div>

        <div class="footer">
            <p>Mancy A.I - Sistema Super-Inteligente v3.0 | Desarrollado con ‚ù§Ô∏è por April/Tito</p>
            <p style="margin-top: 10px; font-size: 0.8rem; opacity: 0.6;">
                <i class="fas fa-shield-alt"></i> Filtro de contenido activado | 
                <i class="fas fa-brain"></i> Razonamiento estrat√©gico | 
                <i class="fas fa-memory"></i> Memoria jer√°rquica
            </p>
        </div>
    </div>

    <script>
        let refreshInterval;
        const API_BASE_URL = window.location.origin;

        // Mostrar notificaci√≥n
        function showNotification(message, type = 'info') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.display = 'block';
            
            if (type === 'success') {
                notification.style.background = 'rgba(0, 176, 155, 0.2)';
                notification.style.borderColor = '#00b09b';
            } else if (type === 'error') {
                notification.style.background = 'rgba(255, 65, 108, 0.2)';
                notification.style.borderColor = '#ff416c';
            } else {
                notification.style.background = 'rgba(33, 147, 176, 0.2)';
                notification.style.borderColor = '#2193b0';
            }
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }

        // A√±adir log al sistema
        function addLog(message) {
            const logsContainer = document.getElementById('systemLogs');
            const now = new Date();
            const timeString = `[${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}]`;
            
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.innerHTML = `<span class="log-time">${timeString}</span><span class="log-message"> ${message}</span>`;
            
            logsContainer.prepend(logEntry);
            
            // Mantener m√°ximo 10 logs
            const logs = logsContainer.querySelectorAll('.log-entry');
            if (logs.length > 10) {
                logs[logs.length - 1].remove();
            }
        }

        // Actualizar estado del sistema
        async function updateStatus() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/status`);
                if (!response.ok) throw new Error('Error al obtener estado');
                
                const data = await response.json();
                
                // Actualizar estado del bot
                const statusBadge = document.getElementById('statusBadge');
                const statusText = document.getElementById('statusText');
                const startBtn = document.getElementById('startBtn');
                const stopBtn = document.getElementById('stopBtn');
                const loadingIndicator = document.getElementById('loadingIndicator');
                
                statusBadge.className = 'status-badge ';
                loadingIndicator.style.display = 'none';
                
                if (data.bot_active) {
                    statusBadge.classList.add('status-online');
                    statusText.textContent = 'CONECTADO';
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                } else if (data.starting_up) {
                    statusBadge.classList.add('status-starting');
                    statusText.textContent = 'INICIANDO...';
                    loadingIndicator.style.display = 'inline-block';
                    startBtn.disabled = true;
                    stopBtn.disabled = true;
                } else {
                    statusBadge.classList.add('status-offline');
                    statusText.textContent = 'DESCONECTADO';
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                }
                
                // Actualizar estad√≠sticas
                document.getElementById('totalMessages').textContent = data.memory_stats?.totalMessages || 0;
                document.getElementById('totalUsers').textContent = data.memory_stats?.totalUsers || 0;
                document.getElementById('reasoningLogs').textContent = data.memory_stats?.queriesProcessed || 0;
                
                // Obtener estad√≠sticas de memoria
                try {
                    const memoryResponse = await fetch(`${API_BASE_URL}/api/memory/stats`);
                    if (memoryResponse.ok) {
                        const memoryData = await memoryResponse.json();
                        document.getElementById('cacheItems').textContent = memoryData.total_messages || 0;
                        document.getElementById('memorySize').textContent = memoryData.memory_file_size || '0 MB';
                    }
                } catch (e) {
                    console.log('No se pudo obtener estad√≠sticas de memoria');
                }
                
                // Actualizar fuentes de conocimiento
                updateApisList(data.capabilities || []);
                
                // Actualizar timestamp
                document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
                
                // Actualizar versi√≥n
                document.getElementById('version').textContent = data.version?.replace('3.0 - Super Inteligente', '3.0') || '3.0';
                
                addLog(`Estado actualizado: ${data.bot_active ? 'Conectado' : 'Desconectado'}`);
                
            } catch (error) {
                console.error('Error al actualizar estado:', error);
                addLog('Error al conectar con el servidor');
                showNotification('No se pudo conectar con el servidor', 'error');
            }
        }

        // Actualizar lista de APIs
        function updateApisList(capabilities) {
            const apisList = document.getElementById('apisList');
            const apis = [
                { name: 'Wikipedia ES/EN', icon: 'fas fa-book', status: 'online' },
                { name: 'RestCountries', icon: 'fas fa-globe-americas', status: 'online' },
                { name: 'PoetryDB', icon: 'fas fa-feather-alt', status: 'online' },
                { name: 'Quotable', icon: 'fas fa-quote-right', status: 'online' },
                { name: 'DictionaryAPI', icon: 'fas fa-book-open', status: 'online' },
                { name: 'Open-Meteo', icon: 'fas fa-cloud-sun', status: 'online' }
            ];
            
            apisList.innerHTML = apis.map(api => `
                <div class="api-item">
                    <i class="${api.icon} api-icon"></i>
                    <span class="api-name">${api.name}</span>
                    <div class="api-status ${api.status}"></div>
                </div>
            `).join('');
        }

        // Iniciar bot
        async function startBot() {
            try {
                const startBtn = document.getElementById('startBtn');
                startBtn.disabled = true;
                startBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Iniciando...';
                
                const response = await fetch(`${API_BASE_URL}/api/start`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showNotification('Mancy se est√° iniciando...', 'success');
                    addLog('Solicitud de inicio enviada');
                    
                    // Actualizar estado despu√©s de 3 segundos
                    setTimeout(updateStatus, 3000);
                } else {
                    showNotification('Error al iniciar: ' + data.error, 'error');
                    addLog('Error al iniciar bot');
                }
                
            } catch (error) {
                console.error('Error al iniciar bot:', error);
                showNotification('Error de conexi√≥n al iniciar bot', 'error');
                addLog('Error de conexi√≥n al iniciar');
            } finally {
                setTimeout(() => {
                    startBtn.disabled = false;
                    startBtn.innerHTML = '<i class="fas fa-play"></i> Iniciar Bot';
                    updateStatus();
                }, 2000);
            }
        }

        // Detener bot
        async function stopBot() {
            if (!confirm('¬øEst√°s seguro de que quieres detener a Mancy? Se guardar√° la memoria antes de apagar.')) {
                return;
            }
            
            try {
                const stopBtn = document.getElementById('stopBtn');
                stopBtn.disabled = true;
                stopBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Deteniendo...';
                
                const response = await fetch(`${API_BASE_URL}/api/stop`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showNotification('Mancy se est√° deteniendo...', 'success');
                    addLog('Solicitud de detenci√≥n enviada');
                    
                    // Actualizar estado despu√©s de 2 segundos
                    setTimeout(updateStatus, 2000);
                } else {
                    showNotification('Error al detener: ' + data.error, 'error');
                    addLog('Error al detener bot');
                }
                
            } catch (error) {
                console.error('Error al detener bot:', error);
                showNotification('Error de conexi√≥n al detener bot', 'error');
                addLog('Error de conexi√≥n al detener');
            } finally {
                setTimeout(() => {
                    updateStatus();
                }, 2000);
            }
        }

        // Refrescar estado
        function refreshStatus() {
            const refreshBtn = document.querySelector('.btn-refresh');
            refreshBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Actualizando...';
            refreshBtn.disabled = true;
            
            updateStatus();
            
            setTimeout(() => {
                refreshBtn.innerHTML = '<i class="fas fa-sync-alt"></i> Actualizar';
                refreshBtn.disabled = false;
                showNotification('Estado actualizado', 'success');
            }, 1000);
        }

        // Inicializar
        document.addEventListener('DOMContentLoaded', () => {
            addLog('Panel de control inicializado');
            updateStatus();
            
            // Actualizar cada 10 segundos
            refreshInterval = setInterval(updateStatus, 10000);
            
            // Detectar si estamos en localhost o Render
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                document.getElementById('serverPort').textContent = '10000 (localhost)';
            } else {
                document.getElementById('serverPort').textContent = window.location.port || '80/443 (Render)';
            }
        });

        // Limpiar intervalo al salir
        window.addEventListener('beforeunload', () => {
            if (refreshInterval) {
                clearInterval(refreshInterval);
            }
        });
    </script>
</body>
</html>
